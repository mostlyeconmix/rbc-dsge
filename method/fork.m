% fork.m: Generates k-step-ahead forecasts from four competing models:
%
%           1) The real business cycle model with indivisible labor,
%                where the matrices D and V are unconstrained.
%
%           2) The real business cycle model with indivisible labor,
%                where the matrices D and V are diagonal.
%
%           3) An unconstrained VAR(1).
%
%           4) An unconstrained VAR(2).
%
%         Forecasts start using the model estimated over the sample
%           period 1948:1-1984:4 and end using the model estimated
%           over the sample period 1948:1-2002:2.
%
%         Requires tstarmat and tstrmatd, the matrices of estimated
%           coefficients for the two versions of the business cycle
%           model generated by estseq.m and estseqd,m.  Uses the
%           function forkfn.m to generate the forecasts from the
%           business cycle models.
%
%         Returns:
%
%           forkmatm = forecasts of [log(Y) log(C) log(I) log(H)]
%                        from the unconstrained business cycle model.
%
%           forkmatd = forecasts of [log(Y) log(C) log(I) log(H)]
%                        from the constrained business cycle model.
%
%           forkmatu = forecasts of [log(Y) log(C) log(I) log(H)]
%                       from the VAR(1).
%
%           forkmat2 = forecasts of [log(Y) log(C) log(I) log(H)]
%                       from the VAR(2).
%
%           rmsem = root mean squared errors, unconstrained business
%                     cycle model
%
%           rmsed = root mean squared errors, constrained business
%                     cycle model
%
%           rmseu = root mean squared errors, VAR(1)
%
%           rmse2 = root mean squared errors, VAR(2)
%
%           ldm = mean loss differentials, unconstrained business cycle
%                   model, using the VAR(1) as a benchmark
%
%           ldsem = standard error of ldm
%
%           ldd = mean loss differentials, constrained business cycle
%                   model, using the VAR(1) as a benchmark
%
%           ldsed = standard error of ldd
%
%           ldm2 = mean loss differentials, unconstrained business cycle
%                    model, using the VAR(2) as a benchmark
%
%           ldsem2 = standard error of ldm2
%
%           ldd2 = mean loss differentials, constrained business cycle
%                    model, using the VAR(2) as a benchmark
%
%           ldsed2 = standard error of ldd2
%
% THIS PROGRAM WAS WRITTEN FOR MATLAB BY
%
%   PETER N. IRELAND
%   BOSTON COLLEGE
%   DEPARTMENT OF ECONOMICS
%   140 COMMONWEALTH AVENUE
%   CHESTNUT HILL, MA 02467
%   irelandp@bc.edu
%
%  FINANCIAL SUPPORT FROM THE NATIONAL SCIENCE FOUNDATION UNDER
%    GRANT NOS. SES-9985763 AND SES-0213461 IS GRATEFULLY ACKNOWLEDGED.
%
%  COPYRIGHT (c) 2003 BY PETER N. IRELAND.  REDISTRIBUTION IS
%    PERMITTED FOR EDUCATIONAL AND RESEARCH PURPOSES, SO LONG AS
%    NO CHANGES ARE MADE.  ALL COPIES MUST BE PROVIDED FREE OF
%    CHARGE AND MUST INCLUDE THIS COPYRIGHT NOTICE.

% load data and parameter estimates

  global yt ct ht

  load ych.dat;

  load tstarmat;

  load tstrmatd;

% set forecast horizon and set up output matrices

  k = 4;

  forkmatm = zeros(71,4);

  forkmatd = zeros(71,4);

  forkmatu = zeros(71,4);

  forkmat2 = zeros(71,4);

% generate forecasts from unconstrained business cycle model

  for j = 1:71

    yt = ych(1:147+j,1);
    ct = ych(1:147+j,2);
    ht = ych(1:147+j,3);

    tstar = [ tstarmat(:,j) ; k ];

    forkmatm(j,:) = forkfn(tstar);

  end

% generate forecasts from constrained business cycle model

  for j = 1:71

    yt = ych(1:147+j,1);
    ct = ych(1:147+j,2);
    ht = ych(1:147+j,3);

    tstar = [ tstrmatd(:,j) ; k ];

    forkmatd(j,:) = forkfn(tstar);

  end

% generate forecasts from VAR(1)

  for j = 1:71

    lyt = log(ych(1:147+j,1));
    lct = log(ych(1:147+j,2));
    lht = log(ych(1:147+j,3));

    trend = 1:147+j;

    xx = [ ones(147+j,1) trend' ];

    bety = inv(xx'*xx)*xx'*lyt;
    betc = inv(xx'*xx)*xx'*lct;
    beth = inv(xx'*xx)*xx'*lht;

    ybar = bety(1);
    ytrend = bety(2);

    cbar = betc(1);
    ctrend = betc(2);

    hbar = beth(1);
    htrend = beth(2);

    dlyt = lyt - ybar - ytrend*trend';
    dlct = lct - cbar - ctrend*trend';
    dlht = lht - hbar - htrend*trend';

    xxx = [ dlyt(1:146+j) dlct(1:146+j) dlht(1:146+j) ];
    yyy = [ dlyt(2:147+j) dlct(2:147+j) dlht(2:147+j) ];

    bigrho = (inv(xxx'*xxx)*xxx'*yyy)';

    bigppp = bigrho;

    dlychtk = (bigrho^k)*yyy(146+j,:)';

    dlytk = dlychtk(1);
    dlctk = dlychtk(2);
    dlhtk = dlychtk(3);

    lytk = dlytk + ybar + ytrend*(147+j+k);
    lctk = dlctk + cbar + ctrend*(147+j+k);
    litk = log(exp(lytk)-exp(lctk));
    lhtk = dlhtk + hbar + htrend*(147+j+k);

    forkmatu(j,:) = [ lytk lctk litk lhtk ];

  end

% generate forecasts from VAR(2)

  for j = 1:71

    lyt = log(ych(1:147+j,1));
    lct = log(ych(1:147+j,2));
    lht = log(ych(1:147+j,3));

    trend = 1:147+j;

    xx = [ ones(147+j,1) trend' ];

    bety = inv(xx'*xx)*xx'*lyt;
    betc = inv(xx'*xx)*xx'*lct;
    beth = inv(xx'*xx)*xx'*lht;

    ybar = bety(1);
    ytrend = bety(2);

    cbar = betc(1);
    ctrend = betc(2);

    hbar = beth(1);
    htrend = beth(2);

    dlyt = lyt - ybar - ytrend*trend';
    dlct = lct - cbar - ctrend*trend';
    dlht = lht - hbar - htrend*trend';

    xxx = [ dlyt(2:146+j) dlct(2:146+j) dlht(2:146+j) ...
            dlyt(1:145+j) dlct(1:145+j) dlht(1:145+j) ];

    yyy = [ dlyt(3:147+j) dlct(3:147+j) dlht(3:147+j) ...
            dlyt(2:146+j) dlct(2:146+j) dlht(2:146+j) ];

    bigrho = (inv(xxx'*xxx)*xxx'*yyy)';

    dlychtk = (bigrho^k)*yyy(145+j,:)';

    dlytk = dlychtk(1);
    dlctk = dlychtk(2);
    dlhtk = dlychtk(3);

    lytk = dlytk + ybar + ytrend*(147+j+k);
    lctk = dlctk + cbar + ctrend*(147+j+k);
    litk = log(exp(lytk)-exp(lctk));
    lhtk = dlhtk + hbar + htrend*(147+j+k);

    forkmat2(j,:) = [ lytk lctk litk lhtk ];

  end

% compute forecast errors

  lyt = log(ych(148+k:218,1));
  lct = log(ych(148+k:218,2));
  lit = log(exp(lyt)-exp(lct));
  lht = log(ych(148+k:218,3));

  ldt = [ lyt lct lit lht ];

  forerrm = forkmatm(1:71-k,:) - ldt;

  forerrd = forkmatd(1:71-k,:) - ldt;

  forerru = forkmatu(1:71-k,:) - ldt;

  forerr2 = forkmat2(1:71-k,:) - ldt;

  ldiffm = forerru.^2 - forerrm.^2;

  ldiffmy = ldiffm(:,1);
  ldiffmc = ldiffm(:,2);
  ldiffmi = ldiffm(:,3);
  ldiffmh = ldiffm(:,4);

  ldiffd = forerru.^2 - forerrd.^2;

  ldiffdy = ldiffd(:,1);
  ldiffdc = ldiffd(:,2);
  ldiffdi = ldiffd(:,3);
  ldiffdh = ldiffd(:,4);

  ldiffm2 = forerr2.^2 - forerrm.^2;

  ldiffm2y = ldiffm2(:,1);
  ldiffm2c = ldiffm2(:,2);
  ldiffm2i = ldiffm2(:,3);
  ldiffm2h = ldiffm2(:,4);

  ldiffd2 = forerr2.^2 - forerrd.^2;

  ldiffd2y = ldiffd2(:,1);
  ldiffd2c = ldiffd2(:,2);
  ldiffd2i = ldiffd2(:,3);
  ldiffd2h = ldiffd2(:,4);

% compute forecast performance statistics

  rmsem = 100*sqrt((1/(71-k))*diag(forerrm'*forerrm));

  rmsed = 100*sqrt((1/(71-k))*diag(forerrd'*forerrd));

  rmseu = 100*sqrt((1/(71-k))*diag(forerru'*forerru));

  rmse2 = 100*sqrt((1/(71-k))*diag(forerr2'*forerr2));

  ldm = mean(ldiffm)';

  ldvarmy = (1/(71-k))*ldiffmy'*ldiffmy;
  ldvarmc = (1/(71-k))*ldiffmc'*ldiffmc;
  ldvarmi = (1/(71-k))*ldiffmi'*ldiffmi;
  ldvarmh = (1/(71-k))*ldiffmh'*ldiffmh;

  for l = 1:k-1

    ldvarmy = ldvarmy + (2/(71-k))*ldiffmy(l+1:71-k)'*ldiffmy(1:71-k-l);
    ldvarmc = ldvarmc + (2/(71-k))*ldiffmc(l+1:71-k)'*ldiffmc(1:71-k-l);
    ldvarmi = ldvarmi + (2/(71-k))*ldiffmi(l+1:71-k)'*ldiffmi(1:71-k-l);
    ldvarmh = ldvarmh + (2/(71-k))*ldiffmh(l+1:71-k)'*ldiffmh(1:71-k-l);

  end

  ldvarm = (1/(71-k))*[ ldvarmy ; ldvarmc ; ldvarmi ; ldvarmh ];

  ldsem = sqrt(ldvarm);

  ldd = mean(ldiffd)';

  ldvardy = (1/(71-k))*ldiffdy'*ldiffdy;
  ldvardc = (1/(71-k))*ldiffdc'*ldiffdc;
  ldvardi = (1/(71-k))*ldiffdi'*ldiffdi;
  ldvardh = (1/(71-k))*ldiffdh'*ldiffdh;

  for l = 1:k-1

    ldvardy = ldvardy + (2/(71-k))*ldiffdy(l+1:71-k)'*ldiffdy(1:71-k-l);
    ldvardc = ldvardc + (2/(71-k))*ldiffdc(l+1:71-k)'*ldiffdc(1:71-k-l);
    ldvardi = ldvardi + (2/(71-k))*ldiffdi(l+1:71-k)'*ldiffdi(1:71-k-l);
    ldvardh = ldvardh + (2/(71-k))*ldiffdh(l+1:71-k)'*ldiffdh(1:71-k-l);

  end

  ldvard = (1/(71-k))*[ ldvardy ; ldvardc ; ldvardi ; ldvardh ];

  ldsed = sqrt(ldvard);

  ldm2 = mean(ldiffm2)';

  ldvarm2y = (1/(71-k))*ldiffm2y'*ldiffm2y;
  ldvarm2c = (1/(71-k))*ldiffm2c'*ldiffm2c;
  ldvarm2i = (1/(71-k))*ldiffm2i'*ldiffm2i;
  ldvarm2h = (1/(71-k))*ldiffm2h'*ldiffm2h;

  for l = 1:k-1

    ldvarm2y = ldvarm2y + (2/(71-k))*ldiffm2y(l+1:71-k)'*ldiffm2y(1:71-k-l);
    ldvarm2c = ldvarm2c + (2/(71-k))*ldiffm2c(l+1:71-k)'*ldiffm2c(1:71-k-l);
    ldvarm2i = ldvarm2i + (2/(71-k))*ldiffm2i(l+1:71-k)'*ldiffm2i(1:71-k-l);
    ldvarm2h = ldvarm2h + (2/(71-k))*ldiffm2h(l+1:71-k)'*ldiffm2h(1:71-k-l);

  end

  ldvarm2 = (1/(71-k))*[ ldvarm2y ; ldvarm2c ; ldvarm2i ; ldvarm2h ];

  ldsem2 = sqrt(ldvarm2);

  ldd2 = mean(ldiffd2)';

  ldvard2y = (1/(71-k))*ldiffd2y'*ldiffd2y;
  ldvard2c = (1/(71-k))*ldiffd2c'*ldiffd2c;
  ldvard2i = (1/(71-k))*ldiffd2i'*ldiffd2i;
  ldvard2h = (1/(71-k))*ldiffd2h'*ldiffd2h;

  for l = 1:k-1

    ldvard2y = ldvard2y + (2/(71-k))*ldiffd2y(l+1:71-k)'*ldiffd2y(1:71-k-l);
    ldvard2c = ldvard2c + (2/(71-k))*ldiffd2c(l+1:71-k)'*ldiffd2c(1:71-k-l);
    ldvard2i = ldvard2i + (2/(71-k))*ldiffd2i(l+1:71-k)'*ldiffd2i(1:71-k-l);
    ldvard2h = ldvard2h + (2/(71-k))*ldiffd2h(l+1:71-k)'*ldiffd2h(1:71-k-l);

  end

  ldvard2 = (1/(71-k))*[ ldvard2y ; ldvard2c ; ldvard2i ; ldvard2h ];

  ldsed2 = sqrt(ldvard2);